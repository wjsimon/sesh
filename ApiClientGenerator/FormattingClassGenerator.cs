using Simons.Generators.HttpClient.Collection;
using Simons.Generators.HttpClient.Collection.Methods;
using Simons.Generators.HttpClient.Helpers;
using System.Text;

namespace Simons.Generators.HttpClient
{
    internal class FormattingClassGenerator
    {
        private AutogenerationCodeContainer _container = new();
        public FormattingClassGenerator AddUsings(IEnumerable<string> usings)
        {
            _container.AddUsings(usings);
            return this;
        }

        public FormattingClassGenerator AddNamespace(string nameSpace)
        {
            _container.SetNamespace($"namespace {nameSpace}");
            return this;
        }

        public FormattingClassGenerator AddClass(AutogenerationInformation classInfo)
        {
            _container.SetClassDefinition($"public{(classInfo.GenerateAsPartial ? " partial" : "")} class {classInfo.ControllerRoute}ApiClient : FastApiClientBase");
            return this;
        }

        public FormattingClassGenerator AddGetOnlyProperty(Type returnValue, string propertyName, string propertyValue)
        {
            _container.AddPublicPropertyDefinition($"public {SwapPrimitive(returnValue)} {propertyName} => \"{propertyValue}\";");
            return this;
        }

        public FormattingClassGenerator AddConstructor(string className, IEnumerable<KeyValuePair<string, string>> parameters, bool passToBase = true)
        {
            StringBuilder sb = new();
            sb.Append($"public {className}(");

            foreach (var p in parameters)
            {
                sb.Append($"{p.Key} {p.Value}, ");
            }

            string step = sb.ToString()[..^2];

            sb = new();
            sb.Append(step);
            sb.Append(")");

            if (passToBase)
            {
                StringBuilder nested = new();
                foreach(var p in parameters)
                {
                    nested.Append($"{p.Value}, ");
                }

                string nstep = nested.ToString()[..^2];

                sb.Append($" : base({nstep})");
            }

            sb.Append(" { }");

            _container.AddPublicConstructorDefinition(sb.ToString());
            return this;
        }

        public FormattingClassGenerator AddPublicMethod(AutogenerationMethodInformation methodInfo)
        {
            _container.AddPublicMethodDefinition(
                MakeMethodDefinition(methodInfo),
                MakeMethodBody(methodInfo)
            );

            return this;
        }

        public string Generate()
            => _container.ToString();

        private static string MakeMethodDefinition(AutogenerationMethodInformation methodInfo)
        {
                return $"public Task{TaskSnippetFromMethodReturnAnnotation(methodInfo)} {methodInfo.MethodName}" +
                       $"({string.Join(", ", methodInfo.ParametersMetaData.Select(tuple => $"{SwapPrimitive(tuple.Type)} {tuple.Name}"))}) ";
        }

        private static List<string> MakeMethodBody(AutogenerationMethodInformation methodInfo) => methodInfo.Type switch
        {
            AutogeneratedMethodType.GET => MakeGetMethodBody(methodInfo), 
            AutogeneratedMethodType.POST => MakePostMethodBody(methodInfo),
            _ => new()
        };

        private static List<string> MakeGetMethodBody(AutogenerationMethodInformation methodInfo)
            => GetMethodBody.Create(methodInfo).ToString();
        
        private static List<string> MakePostMethodBody(AutogenerationMethodInformation methodInfo)
            => PostMethodBody.Create(methodInfo).ToString();

        private static string SwapPrimitive(Type type)
            => TypeHelper.TypeAsCodeSnippet(type);

        private static string TaskSnippetFromMethodReturnAnnotation(AutogenerationMethodInformation methodInfo)
        {
            if (methodInfo.AreNullReturnsAllowed)
            {
                return methodInfo.ReturnType != typeof(void) ? $"<{SwapPrimitive(methodInfo.ReturnType)}?>" : "";
            }
            else
            {
                return methodInfo.ReturnType != typeof(void) ? $"<{SwapPrimitive(methodInfo.ReturnType)}>" : "";
            }
        }
    }
}
